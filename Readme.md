## Множества (sets) представляют структуру данных, которая может хранить только уникальные значения. В JavaScript функционал множества опредляет объект Set. Для создания множества применяется конструктор этого объекта:

```
const mySet = new Set();
```

### Также можно передать в конструктор массив значений, которыми будет инициализировано множество:

```
const arr = [1, 1, 2, 3, 4, 5, 2, 4];
const numbers = new Set(arr);
console.log(numbers);           // Set(5) {1, 2, 3, 4, 5}
```

### В данном случае в множество передаются данные из массива. Однако поскольку множество может хранить только уникальные значения, то при его создании повторяющиеся значения, которые есть в массиве, удаляются

### Для упрощения создания набора мы можем сразу передать массив в конструктор Set:

```
const numbers = new Set([1, 2, 3, 4, 5]);
console.log(numbers);       // Set(5) {1, 2, 3, 4, 5}
```

 <span  style = " color : red; font-size: 30px"> Размер набора </span>

### Для проверки количества элементов можно использовать свойство size.

```
const numbers = new Set([1, 1, 2, 3, 4, 5, 2, 4]);
console.log(numbers.size);      // 5
```

<span  style = " color : red; font-size: 30px">  Добавление

### Для добавления применяется метод add(). Его результатом является измененное множество:

```
const numbers = new Set();
numbers.add(1);
numbers.add(3);
numbers.add(5);
numbers.add(3);     // не добавляется
numbers.add(1);     // не добавляется
console.log(numbers);       // Set(3) {1, 3, 5}
```

### При этом, поскольку множество хранит только уникальные значения, то добавление элементов, которые уже в нем есть, не имеет смысла.

### Так как метод add возвращает ссылку на это же множество, то мы можем вызывать методы по цепочке:

```
const numbers = new Set();
numbers.add(1).add(3).add(5);
console.log(numbers);       // Set(3) {1, 3, 5}
```

<span  style = " color : red; font-size: 30px">  Удаление

### Для удаления элементов применяется метод delete():

```
const numbers = new Set([1, 3, 5]);
numbers.delete(3);
console.log(numbers);       // Set(2) {1, 5}
```

### Причем данный метод возвращает булевое значение: true - если элемент удален и false - если удаление не произошло (например, когда удаляемого элемента нет в множестве):

```
const numbers = new Set([1, 3, 5]);
 
let isDeleted = numbers.delete(3);
console.log(isDeleted);         // true
isDeleted = numbers.delete(54);
console.log(isDeleted);         // false
```

### Если необходимо удалить вообще все элементы из множества, то применяется метод clear():

```
let numbers = new Set();
const numbers = new Set([1, 3, 5]);
numbers.clear();
console.log(numbers);           // Set(0) {}
```

<span  style = " color : red; font-size: 30px">  Проверка наличия элемента

### Если нужно проверить, если ли элемент в множестве, то используется метод has(). Если элемент есть, то метод возвращает true, иначе возвращает false

```
const numbers = new Set([1, 3, 5]);
console.log(numbers.has(3));    // true
console.log(numbers.has(32));   // false
```

<span  style = " color : red; font-size: 30px">  Перебор множества

### Для перебора элементов множества применяется метод forEach():

```
const numbers = new Set([1, 2, 3, 5]);
 
numbers.forEach(function(value1, value2, set){
    console.log(value1);
})
```

### Для совместимости с массивами, которые тоже имеют метод forEach, в данный метод передается функция обратного вызова, которая принимает три параметра. Непосредственно для множества первый и второй параметры представляют текущий перебираемый элемент, а третий параметр - перебираемое множество. В данном случае применяется только первый параметр.

### Также для перебора множества можно использовать цикл for...of:

```
const numbers = new Set([1, 2, 3, 5]);
 
for(n of numbers){
    console.log(n);
}
```

<span  style = " color : red; font-size: 30px">  Удаление из массива повторяющихся элементов

### Ограничения объекта Set - хранения уникальных значений позволяет эффективно его применять в ряде операций. Например, удаление из массива повторяющихся элементов:

```
const peopleArray = ["Tom", "Bob", "Sam", "Alice", "Sam", "Kate", "Tom"];
const peopleSet = new Set(peopleArray);
const newPeopleArray = Array.from(peopleSet);
 
console.log(newPeopleArray);    // ["Tom", "Bob", "Sam", "Alice", "Kate"]
```
=======
## Множества (sets) представляют структуру данных, которая может хранить только уникальные значения. В JavaScript функционал множества опредляет объект Set. Для создания множества применяется конструктор этого объекта:

```
const mySet = new Set();
```

### Также можно передать в конструктор массив значений, которыми будет инициализировано множество:

```
const arr = [1, 1, 2, 3, 4, 5, 2, 4];
const numbers = new Set(arr);
console.log(numbers);           // Set(5) {1, 2, 3, 4, 5}
```

### В данном случае в множество передаются данные из массива. Однако поскольку множество может хранить только уникальные значения, то при его создании повторяющиеся значения, которые есть в массиве, удаляются

### Для упрощения создания набора мы можем сразу передать массив в конструктор Set:

```
const numbers = new Set([1, 2, 3, 4, 5]);
console.log(numbers);       // Set(5) {1, 2, 3, 4, 5}
```

 <span  style = " color : red "> Размер набора </span>

### Для проверки количества элементов можно использовать свойство size.

```
const numbers = new Set([1, 1, 2, 3, 4, 5, 2, 4]);
console.log(numbers.size);      // 5
```

## Добавление

### Для добавления применяется метод add(). Его результатом является измененное множество:

```
const numbers = new Set();
numbers.add(1);
numbers.add(3);
numbers.add(5);
numbers.add(3);     // не добавляется
numbers.add(1);     // не добавляется
console.log(numbers);       // Set(3) {1, 3, 5}
```

### При этом, поскольку множество хранит только уникальные значения, то добавление элементов, которые уже в нем есть, не имеет смысла.

### Так как метод add возвращает ссылку на это же множество, то мы можем вызывать методы по цепочке:

```
const numbers = new Set();
numbers.add(1).add(3).add(5);
console.log(numbers);       // Set(3) {1, 3, 5}
```

## Удаление

### Для удаления элементов применяется метод delete():

```
const numbers = new Set([1, 3, 5]);
numbers.delete(3);
console.log(numbers);       // Set(2) {1, 5}
```

### Причем данный метод возвращает булевое значение: true - если элемент удален и false - если удаление не произошло (например, когда удаляемого элемента нет в множестве):

```
const numbers = new Set([1, 3, 5]);
 
let isDeleted = numbers.delete(3);
console.log(isDeleted);         // true
isDeleted = numbers.delete(54);
console.log(isDeleted);         // false
```

### Если необходимо удалить вообще все элементы из множества, то применяется метод clear():

```
let numbers = new Set();
const numbers = new Set([1, 3, 5]);
numbers.clear();
console.log(numbers);           // Set(0) {}
```

## Проверка наличия элемента

### Если нужно проверить, если ли элемент в множестве, то используется метод has(). Если элемент есть, то метод возвращает true, иначе возвращает false

```
const numbers = new Set([1, 3, 5]);
console.log(numbers.has(3));    // true
console.log(numbers.has(32));   // false
```

## Перебор множества

### Для перебора элементов множества применяется метод forEach():

```
const numbers = new Set([1, 2, 3, 5]);
 
numbers.forEach(function(value1, value2, set){
    console.log(value1);
})
```

### Для совместимости с массивами, которые тоже имеют метод forEach, в данный метод передается функция обратного вызова, которая принимает три параметра. Непосредственно для множества первый и второй параметры представляют текущий перебираемый элемент, а третий параметр - перебираемое множество. В данном случае применяется только первый параметр.

### Также для перебора множества можно использовать цикл for...of:

```
const numbers = new Set([1, 2, 3, 5]);
 
for(n of numbers){
    console.log(n);
}
```

## Удаление из массива повторяющихся элементов

### Ограничения объекта Set - хранения уникальных значений позволяет эффективно его применять в ряде операций. Например, удаление из массива повторяющихся элементов:

```
const peopleArray = ["Tom", "Bob", "Sam", "Alice", "Sam", "Kate", "Tom"];
const peopleSet = new Set(peopleArray);
const newPeopleArray = Array.from(peopleSet);
 
console.log(newPeopleArray);    // ["Tom", "Bob", "Sam", "Alice", "Kate"]
```
